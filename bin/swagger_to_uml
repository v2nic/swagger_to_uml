#!/usr/bin/env python3
# coding=utf-8

# MIT License
#
# Copyright 2017 Niels Lohmann <http://nlohmann.me>
#
# Permission is hereby granted, free of charge, to any person obtaining a copy of this software and associated
# documentation files (the "Software"), to deal in the Software without restriction, including without limitation the
# rights to use, copy, modify, merge, publish, distribute, sublicense, and/or sell copies of the Software, and to
# permit persons to whom the Software is furnished to do so, subject to the following conditions:
#
# The above copyright notice and this permission notice shall be included in all copies or substantial portions of
# the Software.
#
# THE SOFTWARE IS PROVIDED "AS IS", WITHOUT WARRANTY OF ANY KIND, EXPRESS OR IMPLIED, INCLUDING BUT NOT LIMITED TO THE
# WARRANTIES OF MERCHANTABILITY, FITNESS FOR A PARTICULAR PURPOSE AND NONINFRINGEMENT. IN NO EVENT SHALL THE AUTHORS
# OR COPYRIGHT HOLDERS BE LIABLE FOR ANY CLAIM, DAMAGES OR OTHER LIABILITY, WHETHER IN AN ACTION OF CONTRACT, TORT
# OR OTHERWISE, ARISING FROM, OUT OF OR IN CONNECTION WITH THE SOFTWARE OR THE USE OR OTHER DEALINGS IN THE SOFTWARE.

import json
import sys
from typing import List, Optional, Any, Set
import xml.etree.ElementTree as ET


def resolve_ref(ref):
    return ref.split('/')[-1]


class Property:
    def __init__(self, name, type, required, example=None, description=None, default=None, enum=None, format=None,
                 items=None, maximum=None, exclusive_maximum=False, minimum=None, exclusive_minimum=False,
                 multiple_of=None, max_length=None, min_length=0, pattern=None, max_items=None, min_items=0,
                 unique_items=False, ref_type=None):
        # type
        self.type = type  # type: str
        self.format = format  # type: Optional[str]
        self.ref_type = ref_type  # type: Optional[str]

        # constraints
        self.required = required  # type: bool
        self.enum = enum  # type: Optional[List[Any]]

        # documentation
        self.name = name  # type: str
        self.example = example  # type: Optional[Any]
        self.description = description  # type: Optional[str]
        self.default = default  # type: Optional[Any]

        # numbers
        self.maximum = maximum  # type: Optional[float,int]
        self.exclusive_maximum = exclusive_maximum  # type: bool
        self.minimum = minimum  # type: Optional[float,int]
        self.exclusive_minimum = exclusive_minimum  # type: bool
        self.multiple_of = multiple_of  # type: Optional[float,int]

        # strings
        self.max_length = max_length  # type: Optional[int]
        self.min_length = min_length  # type: int
        self.pattern = pattern  # type: Optional[str]

        # arrays
        self.max_items = max_items  # type: Optional[int]
        self.min_items = min_items  # type: int
        self.unique_items = unique_items  # type: bool
        self.items = items  # type: Optional[str]

    @staticmethod
    def from_dict(property_name, d, required):
        # whether the type was resolved
        ref_type = None

        # We use the Parameter class for parameters inside the swagger specification, but also for parameters. There,
        # type information is given in a "schema" property.
        if 'type' in d or '$ref' in d:
            type_dict = d
        elif 'schema' in d:
            type_dict = d['schema']
        elif 'allOf' in d and len(d['allOf']) > 0:
            type_dict = d['allOf'][0]
        else:
            type_dict = {}

        # type is given or must be resolved from $ref
        if 'type' in type_dict:
            type_str = type_dict['type']
        elif '$ref' in type_dict:
            type_str = resolve_ref(type_dict['$ref'])
            ref_type = type_str
        else:
            type_str = '<i>not specified</i>'

        # join multiple types to string
        if isinstance(type_str, list):
            type_str = '/'.join(type_str)

        # items type is given or must be resolved from $ref
        if 'items' in type_dict:
            if 'type' in type_dict['items']:
                items = type_dict['items']['type']
            else:
                items = resolve_ref(type_dict['items']['$ref'])
                ref_type = items
        else:
            items = None

        return Property(
            name=property_name,
            type=type_str,
            required=required,
            example=d.get('example'),
            description=d.get('description'),
            default=d.get('default'),
            enum=d.get('enum'),
            format=d.get('format'),
            items=items,
            maximum=d.get('maximum'),
            exclusive_maximum=d.get('exclusiveMaximum', False),
            minimum=d.get('minimum'),
            exclusive_minimum=d.get('exclusiveMinimum', False),
            multiple_of=d.get('multipleOf'),
            max_length=d.get('maxLength'),
            min_length=d.get('minLength', 0),
            pattern=d.get('pattern'),
            max_items=d.get('maxItems', 0),
            min_items=d.get('minItems'),
            unique_items=d.get('uniqueItems', False),
            ref_type=ref_type
        )

    @property
    def uml(self):
        # type or array
        if self.type == 'array':
            # determine lower and upper bound
            lower = ''
            upper = ''
            if self.min_items:
                lower = self.min_items if not self.exclusive_minimum else self.min_items + 1
            if self.max_items:
                upper = self.max_items if not self.exclusive_minimum else self.max_items - 1

            # combine lower and upper bound to bounds string
            bounds = ''
            if lower or upper:
                bounds = '{lower}:{upper}'.format(lower=lower, upper=upper)

            type_str = '{items}[{bounds}]'.format(items=self.items, bounds=bounds)
        else:
            type_str = self.type

        # format (e.g., date-time)
        if self.format:
            type_str += ' ({format})'.format(format=self.format)

        # name string (bold if property is required)
        if self.required:
            name_str = '<b>{name}</b>'.format(name=self.name)
        else:
            name_str = self.name

        # simple type definition ({field} is a keyword for PlantUML)
        result = '{{field}} {type_str} {name_str}'.format(type_str=type_str, name_str=name_str)

        # enum
        if self.enum is not None:
            result += ' {{{enum_str}}}'.format(enum_str=', '.join([json.dumps(x) for x in self.enum]))

        # min/max
        if self.minimum or self.maximum:
            minimum = self.minimum if self.minimum is not None else ''
            maximum = self.maximum if self.maximum is not None else ''
            result += ' {{{minimum}..{maximum}}}'.format(minimum=minimum, maximum=maximum)

        # default value
        if self.default is not None:
            result += ' = {default}'.format(default=json.dumps(self.default))

        return result


class Definition:
    def __init__(self, name, type, properties, relationships):
        self.name = name  # type: str
        self.type = type  # type: str
        self.properties = properties  # type: List[Property]
        self.relationships = relationships  # type: Set[str]

    @staticmethod
    def from_dict(name, d):
        properties = []  # type: List[Property]
        for property_name, property in d.get('properties', {}).items():
            properties.append(Property.from_dict(
                property_name=property_name,
                d=property,
                required=property_name in d.get('required', [])
            ))

        if not 'type' in d:
            print('required key "type" not found in dictionary ' + json.dumps(d), file=sys.stderr)

        return Definition(name=name,
                          type=d['type'],
                          properties=properties,
                          relationships={property.ref_type for property in properties if property.ref_type})

    @property
    def uml(self):
        # If this is a simpleType with enumeration values, render as an enum
        if self.type == 'simpleType' and self.properties:
            enum_values = None
            # Take enum values from the first property that defines an enum
            for prop in self.properties:
                if getattr(prop, 'enum', None):
                    enum_values = prop.enum
                    break
            if enum_values:
                # Render a PlantUML enum with one literal per line
                lines = []
                lines.append('enum {name} {{'.format(name=self.name))
                for v in enum_values:
                    # Keep JSON-style quoting to preserve spaces and punctuation in values
                    lines.append('    {val}'.format(val=json.dumps(v)))
                lines.append('}')
                lines.append('')
                return '\n'.join(lines)

        # Default rendering as class
        result = 'class {name} {{\n'.format(name=self.name)

        # required properties first
        for property in sorted(self.properties, key=lambda x: x.required, reverse=True):
            result += '    {property_str}\n'.format(property_str=property.uml)

        result += '}\n\n'

        # add relationships
        for relationship in sorted(self.relationships):
            result += '{name} ..> {relationship}\n'.format(name=self.name, relationship=relationship)

        return result


class XSDDefinition:
    def __init__(self, name, type, properties, relationships):
        self.name = name  # type: str
        self.type = type  # type: str
        self.properties = properties  # type: List[Property]
        self.relationships = relationships  # type: Set[str]
    
    @staticmethod
    def _quote_class_name(name):
        """Quote class names that contain special characters for PlantUML compatibility."""
        import re
        # If the name contains characters that are not alphanumeric or underscore, quote it
        if re.search(r'[^A-Za-z0-9_]', name):
            return f'"{name}"'
        return name

    @staticmethod
    def from_element(name, element, element_types=None, simple_types=None):
        properties = []  # type: List[Property]
        relationships = set()
        element_types = element_types or {}
        simple_types = simple_types or {}
        
        # Handle complexType elements
        if element.tag.endswith('}complexType'):
            # Find descendant elements in sequences/choices (covers complexContent/extension cases)
            descendants = []
            # Handle both direct sequences and those within complexContent/extension
            for path in ('.//{*}sequence/{*}element', './/{*}choice/{*}element', './/{*}complexContent/{*}extension/{*}sequence/{*}element'):
                descendants.extend(element.findall(path))

            for prop_element in descendants:
                # Check if it's a reference to another element
                if prop_element.get('ref'):
                    ref_name = prop_element.get('ref')
                    # Extract local name from qualified name (namespace:localname)
                    if ':' in ref_name:
                        namespace_prefix = ref_name.split(':')[0]
                        prop_name = ref_name.split(':')[-1]
                        prop_type = ref_name.split(':')[-1]
                        # Determine if referenced element resolves to a simple xs:* type
                        resolved_type = element_types.get(prop_name)
                        is_simple = False
                        if resolved_type:
                            # If element type is named, see if that named simpleType's base is xs:*
                            local = resolved_type.split(':')[-1]
                            st = simple_types.get(local)
                            if st and st.get('base_prefix') == 'xs' and not st.get('has_enum'):
                                is_simple = True
                                # Set field type to the xs base (e.g., xs:anyURI)
                                base_local = st.get('base_local')
                                if base_local:
                                    prop_type = f"xs:{base_local}"
                            elif ':' in resolved_type and resolved_type.split(':')[0] == 'xs':
                                is_simple = True
                                # resolved directly to an xs:* type
                                prop_type = resolved_type
                            else:
                                # Not simple: use the resolved named type as the field type
                                prop_type = local
                                relationships.add(local)
                        # Only add relationship if not simple
                        if not is_simple and namespace_prefix != 'xs':
                            # relationship already added above when resolved_type is named
                            # If we didn't have resolved_type, fall back to element name
                            if not resolved_type:
                                relationships.add(prop_type)
                    else:
                        prop_name = ref_name
                        prop_type = ref_name
                        # Best effort: assume unknown local refs are complex
                        relationships.add(prop_type)
                else:
                    # It's a direct element definition
                    prop_name = prop_element.get('name', '')
                    prop_type = prop_element.get('type', 'string')
                    
                    # Handle namespace prefixes in type
                    if ':' in prop_type:
                        namespace_prefix = prop_type.split(':')[0]
                        local_type = prop_type.split(':')[-1]
                        # If it's a reference to a built-in type, keep the prefix for clarity
                        if namespace_prefix == 'xs':
                            prop_type = 'xs:' + local_type
                        else:
                            # Non-built-in named type: set local name and add relationship
                            prop_type = local_type
                            # Non-built-in named type: set local name and add relationship
                            # But suppress relationship if that named simpleType base is xs:*
                            st = simple_types.get(local_type)
                            if not (st and st.get('base_prefix') == 'xs' and not st.get('has_enum')):
                                relationships.add(local_type)
                    else:
                        # If no prefix, check if this is a named complexType
                        # Add relationship if the type name exists in our element_types or simple_types
                        if prop_type in element_types or prop_type in simple_types:
                            relationships.add(prop_type)
                        elif prop_type != 'string' and not prop_type.startswith('xs:'):
                            relationships.add(prop_type)
                
                properties.append(Property(
                    name=prop_name,
                    type=prop_type,
                    required=prop_element.get('minOccurs', '1') != '0'
                ))

            # Process descendant attributes
            for child in element.findall('.//{*}attribute'):
                attr_name = child.get('name', '')
                attr_type = child.get('type', 'string')
                
                # Handle namespace prefixes in type
                if ':' in attr_type:
                    attr_type = attr_type.split(':')[-1]
                
                properties.append(Property(
                    name=attr_name,
                    type=attr_type,
                    required=child.get('use', 'optional') == 'required'
                ))
        
        # Handle simpleType elements with enumerations
        elif element.tag.endswith('}simpleType'):
            for child in element:
                if child.tag.endswith('}restriction'):
                    enum_values = []
                    for enum_child in child:
                        if enum_child.tag.endswith('}enumeration'):
                            enum_values.append(enum_child.get('value'))
                    
                    if enum_values:
                        properties.append(Property(
                            name='value',
                            type='enum',
                            required=True,
                            enum=enum_values
                        ))
        
        return XSDDefinition(name=name,
                             type='complexType' if element.tag.endswith('}complexType') else 'simpleType',
                             properties=properties,
                             relationships=relationships)

    @property
    def uml(self):
        # If this is a simpleType with enumeration values, render as an enum
        if self.type == 'simpleType' and self.properties:
            enum_values = None
            for prop in self.properties:
                if getattr(prop, 'enum', None):
                    enum_values = prop.enum
                    break
            if enum_values:
                lines = []
                quoted_name = self._quote_class_name(self.name)
                lines.append('enum {name} {{'.format(name=quoted_name))
                for v in enum_values:
                    lines.append('    {val}'.format(val=json.dumps(v)))
                lines.append('}')
                lines.append('')
                return '\n'.join(lines)

        # Default: render as class
        quoted_name = self._quote_class_name(self.name)
        result = 'class {name} {{\n'.format(name=quoted_name)

        # required properties first
        for property in sorted(self.properties, key=lambda x: x.required, reverse=True):
            result += '    {property_str}\n'.format(property_str=property.uml)

        result += '}\n\n'

        # add relationships
        for relationship in sorted(self.relationships):
            quoted_relationship = self._quote_class_name(relationship)
            result += '{name} ..> {relationship}\n'.format(name=quoted_name, relationship=quoted_relationship)

        return result


class XSDSchema:
    def __init__(self, definitions, substitution_groups=None):
        self.definitions = definitions  # type: List[XSDDefinition]
        self.substitution_groups = substitution_groups or {}  # type: dict[str, set[str]]
    
    @staticmethod
    def from_file(filename):
        # Parse the XSD file
        tree = ET.parse(filename)
        root = tree.getroot()
        
        definitions = []
        processed_types = set()
        # Build an index of top-level element name -> type across all XSDs in the directory
        import os, glob
        element_types = {}
        # map of named simpleType -> {base_prefix, base_local, has_enum}
        simple_types = {}
        substitution_groups = {}
        base_dir = os.path.dirname(filename)
        for xsd_path in glob.glob(os.path.join(base_dir, '*.xsd')):
            try:
                other_tree = ET.parse(xsd_path)
                other_root = other_tree.getroot()
                # collect top-level elements (name -> type)
                for el in other_root.findall('./{*}element'):
                    n = el.get('name')
                    t = el.get('type')
                    if n and t:
                        element_types[n] = t
                    sg = el.get('substitutionGroup')
                    if n and sg:
                        head = sg.split(':')[-1]
                        substitution_groups.setdefault(head, set()).add(n)
                # collect named simpleTypes
                for st in other_root.findall('./{*}simpleType'):
                    st_name = st.get('name')
                    if not st_name:
                        continue
                    base_prefix = None
                    base_local = None
                    has_enum = False
                    restr = st.find('./{*}restriction')
                    if restr is not None:
                        base = restr.get('base')
                        if base:
                            if ':' in base:
                                base_prefix = base.split(':')[0]
                                base_local = base.split(':')[-1]
                            else:
                                base_local = base
                        for enum_child in restr.findall('./{*}enumeration'):
                            has_enum = True
                            break
                    simple_types[st_name] = {
                        'base_prefix': base_prefix,
                        'base_local': base_local,
                        'has_enum': has_enum,
                    }
            except Exception:
                continue
        
        # Process named complexType definitions across ALL XSDs
        for xsd_path in glob.glob(os.path.join(base_dir, '*.xsd')):
            try:
                other_tree = ET.parse(xsd_path)
                other_root = other_tree.getroot()
                for complex_type in other_root.findall('.//{*}complexType[@name]'):
                    name = complex_type.get('name')
                    if name and name not in processed_types:
                        definitions.append(XSDDefinition.from_element(name, complex_type, element_types, simple_types))
                        processed_types.add(name)
                # Process named simpleType definitions with enums across ALL XSDs
                for simple_type in other_root.findall('.//{*}simpleType[@name]'):
                    name = simple_type.get('name')
                    if name and name not in processed_types:
                        st_info = simple_types.get(name)
                        if st_info and st_info.get('has_enum'):
                            definitions.append(XSDDefinition.from_element(name, simple_type, element_types, simple_types))
                            processed_types.add(name)
            except Exception:
                continue
        
        # Process top-level elements that have complexType definitions
        # Only process elements with complex types, not simple types like xs:string, xs:boolean, etc.
        def handle_top_level_elements(parent_root):
            for element in parent_root.findall('./{*}element'):
                name = element.get('name')
                type_attr = element.get('type')
                
                # If element has a type attribute
                if name and type_attr:
                    # Handle namespace prefixes in type
                    if ':' in type_attr:
                        type_prefix = type_attr.split(':')[0]
                        type_name = type_attr.split(':')[-1]
                        # Skip simple built-in types (xs:string, xs:boolean, etc.)
                        if type_prefix == 'xs':
                            continue
                        # Skip elements whose named type is a simpleType with xs:* base and no enum (e.g., MarketContextType)
                        st_info = simple_types.get(type_name)
                        if st_info and st_info.get('base_prefix') == 'xs' and not st_info.get('has_enum'):
                            continue
                    else:
                        # No prefix; treat as simple name
                        type_name = type_attr
                    
                    # Always ensure the wrapper has an association to the named type
                    if name not in processed_types:
                        # Create a simple property definition
                        properties = [Property(name='element', type=type_name, required=True)]
                        definitions.append(XSDDefinition(name=name, type='element', properties=properties, relationships={type_name}))
                        processed_types.add(name)
                    else:
                        # Update existing definition to ensure relationship exists
                        for d in definitions:
                            if getattr(d, 'name', None) == name:
                                d.relationships.add(type_name)
                                # Ensure it has at least one field reflecting the element type
                                if not any(f.name == 'element' for f in d.properties):
                                    d.properties.append(Property(name='element', type=type_name, required=True))
                                break

        # Handle elements in the root file
        handle_top_level_elements(root)
        # And across all sibling XSDs to pick up wrappers like ServiceDeliveryPoint
        for xsd_path in glob.glob(os.path.join(base_dir, '*.xsd')):
            try:
                other_tree = ET.parse(xsd_path)
                other_root = other_tree.getroot()
                handle_top_level_elements(other_root)
            except Exception:
                continue
        
        # Final pass: ensure every top-level element in element_types has a wrapper
        existing_names = {getattr(d, 'name', '') for d in definitions}
        for el_name, t in element_types.items():
            if not el_name or not t:
                continue
            # Skip xs:*
            if ':' in t and t.split(':')[0] == 'xs':
                continue
            type_name = t.split(':')[-1]
            st_info = simple_types.get(type_name)
            if st_info and st_info.get('base_prefix') == 'xs' and not st_info.get('has_enum'):
                continue
            if el_name not in existing_names:
                properties = [Property(name='element', type=type_name, required=True)]
                definitions.append(XSDDefinition(name=el_name, type='element', properties=properties, relationships={type_name}))
                existing_names.add(el_name)
        
        return XSDSchema(definitions=definitions, substitution_groups=substitution_groups)

    @property
    def uml(self):
        # Build substitution group UML blocks
        group_blocks = []
        for head, members in sorted(self.substitution_groups.items()):
            if members:
                group_blocks.append(XSDSubstitutionGroup(head, members).uml)
        uml_str = '@startuml\nhide empty members\nset namespaceSeparator none\n\n{definitions}\n\n{groups}\n@enduml\n'
        return uml_str.format(
            definitions='\n\n'.join([d.uml for d in self.definitions]),
            groups='\n\n'.join(group_blocks)
        )

class XSDSubstitutionGroup:
    def __init__(self, head, members):
        self.head = head  # type: str
        self.members = sorted(list(members))  # type: List[str]

    @property
    def uml(self):
        # Render head as abstract class with a stereotype and member inheritance
        lines = []
        lines.append('abstract class {head} <<substitutionGroupHead>>'.format(head=self.head))
        lines.append('')
        for m in self.members:
            lines.append('{member} --|> {head}'.format(member=m, head=self.head))
        lines.append('')
        return '\n'.join(lines)


class Parameter:
    def __init__(self, name, location, description, required, property):
        self.name = name  # type: str
        self.location = location  # type: str
        self.description = description  # type: Optional[str]
        self.required = required  # type: bool
        self.property = property  # type: Property

    @staticmethod
    def from_dict(whole, d):
        ref = d.get('$ref')
        if ref != None:
            d = whole['parameters'][resolve_ref(ref)]
        return Parameter(
            name=d['name'],
            location=d['in'],
            description=d.get('description'),
            required=d.get('required', False),
            property=Property.from_dict(d['name'], d, d.get('required', False))
        )


class Response:
    def __init__(self, status, description, property):
        self.status = status  # type: str
        self.description = description  # type: Optional[str]
        self.property = property  # type: Property

    @staticmethod
    def from_dict(whole, status, d):
        return Response(
            status=status,
            description=d.get('description'),
            property=Property.from_dict('', d, False)
        )

    @property
    def uml(self):
        return '{status}: {type}'.format(
            status=self.status,
            type=self.property.uml
        )


class Operation:
    def __init__(self, path, type, summary, description, responses, tags, parameters):
        self.path = path  # type: str
        self.type = type  # type: str
        self.summary = summary  # type: Optional[str]
        self.description = description  # type: Optional[str]
        self.responses = responses  # type: List[Response]
        self.tags = tags  # type: List[str]
        self.parameters = parameters  # type: List[Parameter]

    def __lt__(self, other):
        return self.type < other.type

    @staticmethod
    def from_dict(whole, path, type, d, path_parameters):
        return Operation(
            path=path,
            type=type,
            summary=d.get('summary'),
            description=d.get('description'),
            tags=d.get('tags'),
            responses=[Response.from_dict(whole, status, response) for status, response in d['responses'].items()],
            parameters=path_parameters + [Parameter.from_dict(whole, param) for param in d.get('parameters', [])]
        )

    @property
    def uml(self):
        # collect used parameter locations
        possible_types = ['header', 'path', 'query', 'body', 'formData']
        parameter_types = {x.location for x in self.parameters}

        parameter_strings = []
        for parameter_type in [x for x in possible_types if x in parameter_types]:
            # add heading
            parameter_strings.append('.. {parameter_type} ..'.format(parameter_type=parameter_type))
            # add parameters
            for parameter in [x for x in self.parameters if x.location == parameter_type]:
                parameter_strings.append('{parameter_uml}'.format(parameter_uml=parameter.property.uml))

        # collect references from responses and parameters
        references = [x.property.ref_type for x in self.responses if x.property.ref_type] + \
                     [x.property.ref_type for x in self.parameters if x.property.ref_type]

        return """class "{name}" {{\n{parameter_str}\n.. responses ..\n{response_str}\n}}\n\n{associations}\n""".format(
            name=self.name,
            response_str='\n'.join([x.uml for x in self.responses]),
            parameter_str='\n'.join(parameter_strings),
            associations='\n'.join({'"{name}" ..> {type}'.format(name=self.name, type=type) for type in references})
        )

    @property
    def name(self):
        return '{type} {path}'.format(
            type=self.type.upper(),
            path=self.path
        )


class Path:
    def __init__(self, path, operations):
        self.path = path  # type: str
        self.operations = operations  # type: List[Operation]

    @staticmethod
    def from_dict(whole, path_name, d):
        parameters = [Parameter.from_dict(whole, param) for param in d.get('parameters', [])]
        return Path(
            path=path_name,
            operations=[Operation.from_dict(whole, path_name, t, op, parameters) for t, op in d.items() if t not in ['parameters', 'summary', 'description']]
        )

    @property
    def uml(self):
        return 'interface "{path}" {{\n}}\n\n{operation_str}\n{association_str}\n\n'.format(
            path=self.path,
            operation_str='\n'.join([op.uml for op in self.operations]),
            association_str='\n'.join(['"{path}" ..> "{operation_name}"'.format(
                path=self.path, operation_name=op.name) for op in sorted(self.operations)])
        )


class Swagger:
    def __init__(self, definitions, paths):
        self.definitions = definitions  # type: List[Definition]
        self.paths = paths  # type: List[Path]

    @staticmethod
    def from_dict(d):
        definitions = [Definition.from_dict(name, definition) for name, definition in d.get('definitions',{}).items()]
        paths = [Path.from_dict(d, path_name, path) for path_name, path in d['paths'].items()]
        return Swagger(definitions=definitions, paths=paths)

    @staticmethod
    def from_file(filename):
        loader = json.load
        if filename.endswith('.yml') or filename.endswith('.yaml'):
            import yaml
            loader = yaml.load
        with open(filename, 'r') as fd:
            return Swagger.from_dict(loader(fd))

    @property
    def uml(self):
        uml_str = '@startuml\nhide empty members\nset namespaceSeparator none\n\n{paths}\n{definitions}\n@enduml\n'
        return uml_str.format(
            paths='\n\n'.join([d.uml for d in self.paths]),
            definitions='\n\n'.join([d.uml for d in self.definitions])
        )


if __name__ == '__main__':
    input_file_name = sys.argv[1]
    
    # Check if it's an XSD file
    if input_file_name.endswith('.xsd'):
        xsd = XSDSchema.from_file(input_file_name)
        print(xsd.uml, end='', flush=True)
    else:
        sw = Swagger.from_file(input_file_name)
        print(sw.uml, end='', flush=True)
